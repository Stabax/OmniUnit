# 1. How to use units #

## Use units ##

All the library is under the namespace omni::.

OmniUnit defines most of the main physical units from the metric, imperial, astronomic and micriscopic systems.
You can find all the predefined units in the related pages.
If you want to use a unit which is not predefined in OmniUnit, look at __how to create units__.

Units are generic. When you use them, you have to precise the arithmetic type which is handled inside them :

    omni::gram<int> var1(10);     //var1 equals 10
    omni::gram<int> var2(12.9);   //var2 equals 12, the value is truncated, not rounded
    omni::gram<float> var3(12.9); //var3 equals 12.9
    //you can of course use any primitive type

    var1 = var3; //var1 equals 12, the value is truncated, not rounded

If you don't need units to handle different types, you can use the default type. Units using the default type begin with a capital :

    #define OMNI_DEFAULT_TYPE float //not mandatory, this value equals "double" by default

    omni::meter<> var4(0); //the internal type of var4 is float
    omni::Meter var5(0); //notice the capital
    //var4 and var5 are exaclty the same, but the definition of var5 is most user friendly

So __all__ non-defaulted units begin with a tiny, while __all__ defaulted units begin with a capital.


## Implicit conversions ##

You can convert a unit to another **if they have the same dimension** (mass in these examples) :

    omni::kilogram<float> var1(3.1);
    omni::milligram<float> var2(var1);  //conversion by construction
    omni::milligram<float> var3 = var1; //conversion by assignment
    //var2 and var3 equal 3100000

you can of course use conversion by explicit cast :

    auto var4 = omni::unit_cast<omni::microgram<int>>(var1); //var4 is a microgram<int>
    auto var5 = omni::unit_cast<omni::milli>(var1);          //var5 is a gram<float> (because kilogram is the base mass unit)
    auto var6 = omni::unit_cast<short>(var1);                //var6 is a kilogram<short>
    auto var7 = omni::unit_cast<omni::E1>(var1);             //var1 looks like a kilogram<float> but with origin = 10 (see the meaning of origin of a unit in "how to create units")

## Compile-time dimension check ##

Dimension check is done at compile-time, which mean that if you made a dimensional error, the code won't compile. It is one of the goals of omniunit, preventing calculation errors.

    omni::def::kilometer var1(1);
    omni::def::hour var2(1);

    omni::def::gram var3 = var1/var2;
    //ERROR : var3 is of dimension MASS while var1/var2 is of dimension SPEED. This doesn't compile

    omni::meterPerSecond var4 = var1/var2;
    //OK, although var1/var2 returns kilometerPerHour, it and var4 have the same dimension. There will just be an implicit conversion

## Compliance between standard duration and OmniUnit duration ##

If you are familiar with standard duration (std::chrono::duration), you may want to use and convert them into OmniUnit duration, and vice versa.
Happily, there is a full compliance between them. You can simply do this by constructing or assigning them :

    omni::millisecond<float> omni1(1.8);
    std::chrono::hours std1(omni1); //construction
    //notice that here, std::chrono::hours handle an integer while omni::millisecond<float> handle a float, so trucation may appear

    std::chrono::hours std2 = omni1; //assignment
    //idem

    //reciprocally
    omni1 = std2; //assignment
    omni::year<int> omni2(std2); //construction

conversion by explicit cast :

    auto omni4 = omni::unit_cast<omni::second<int>>(std3);
    auto std4 = omni::unit_cast<std::chrono::nanoseconds>(omni3);

However, you can't use an implicit conversion between standard and OmniUnit duration to pass a parameter to a function, you have to do that explicitly :

    void foo1(std::chrono::hours) {//do something};
    void foo2(omni::second<int>) {//do something};

    std::chrono::seconds standard(1);
    omni::millisecond<float> omni5(2.1);

    foo1(omni5); //ERROR
    foo1(std::chrono::hours(omni5)); //OK
    foo1(omni::duration_cast<std::chrono::hours>(omni5)); //OK

    foo2(standard1); //ERROR
    foo2(omni::second<int>(standard1)); //OK
    foo2(omni::duration_cast<omni::second<int>(standard)); //OK

The previous tips may be useful if you want to pass an omni::duration to std::this_thread::sleep_for(), for exemple.

## Mathematic functions ##

The five main operators are provided : +-*/% (together with +=, -=, *=, /=, %=, ++, -- and unary -)

    omni::


Of course, using units only with these main operators looks limited. Others 


## Constexpr instances ##


## Runetime errors and exception safety ##

Most of the library works at compile time, there is absolutly no exception throwing in order to allow constexpr units (see the previous section).
Nevertheless, **there is no** "no throw guarentee" because some __standard__ functions (exp, log, pow, round, cos...) used in Omniunit at execution-time may (or not) throw. See the exception safety of these functions in the C++ standard documentation.

The others errors that could occur during execution are :
* domain errors like division by zero, or calculating log(0) : to follow the C++ standard, the behavior in OmniUnit is undefined ;
* too large or too small numbers (obtained for exemple by conversion or by exp/pow functions) : again, the behavior is the same as the C++ standard when you reach the maximum of a variable.