<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OmniUnit: How to create units</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OmniUnit
   </div>
   <div id="projectbrief">OmniUnit is a modern C++ header only library to represent physical units</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to create units </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To define your own unit, you need to provide 3 informations : its dimension, its ratio and its origin. All must be done in a header file.</p>
<h2>Step 1 : Dimension</h2>
<p>The class <a class="el" href="structomni_1_1Dimension.html">omni::Dimension</a> has 9 template parameters which define the 7 basic international dimensions and 2 angular "dimensions". These parameters are, in order : length, mass, time, electric intensity, temperature, quantity, luminous intensity, angle and solid angle.</p>
<p>So, here are some examples of dimension definition :</p>
<pre class="fragment">typedef omni::Dimension&lt;1, 0, 0, 0, 0, 0, 0, 0, 0&gt; Length;
typedef omni::Dimension&lt;0, 0, 1, 0, 0, 0, 0, 0, 0&gt; Duration;
typedef omni::Dimension&lt;0, 0, -1, 0, 0, 0, 0, 0, 0&gt; Frequency;
typedef omni::Dimension&lt;1, 0, -1, 0, 0, 0, 0, 0, 0&gt; Speed;
typedef omni::Dimension&lt;2, 1, -2, 0, 0, 0, 0, 0, 0&gt; Energy;
typedef omni::Dimension&lt;0, 1, -2, -1, 0, 0, 0, 0, 0&gt; MegneticField;
</pre><p><b>Tips</b> : the function omni::dimension_str&lt;&gt;() returns a std::string containing the dimension passed as template argument, if you want to print it. </p><pre class="fragment">std::string dim = omni::dimension_str&lt;MegneticField&gt;();
std::cout &lt;&lt; dim &lt;&lt; "\n"; //prints: [M1][Tm-2][I-1]
</pre><h2>Step 2 : Ratio</h2>
<p>The ratio indicates what the unit represents according to the basic international unit of the considered dimension.<br />
For example, the basic unit of a length is the meter, represented by a ratio equal to 1 : it is the base. The basic unit of a force is the newton, for a magnetic field it is the tesla... They are all represented by a ratio equal to 1 because they are the basic international unit of their dimension.<br />
Thus, one millimeter represents 0.001 meter, namely 1/1000 meter. Obviously, the ratio for a millimeter is 1/1000, 1/1000000 for a micrometer, 1000/1 for a kilometer... 1/2 for a half-meter !<br />
 Well, <a class="el" href="structomni_1_1Ratio.html">omni::Ratio</a> is a type which takes two values (a numerator and a denominator) as <b>non-type</b> template parameters. These parameters <b>HAVE TO</b> be of type <b>inline constexpr double</b>. <br />
<b>Double</b> are needed for technical reasons (the greater value reachable with an integer or a float is too short to represent all possible units, this is why OmniUnit doesn't use std::ratio). <b>Inline</b> is needed to be guaranteed that the variable will be the same in all translation units (It is why OmniUnit requires C++17). If not, the user will have linker errors when using these variables...</p>
<p>Moreover, a template parameter can only be taken as double if the parameter :</p>
<ul>
<li>is <b>known at compile time</b>, so it has to be <b>constexpr</b>. A constexpr variable must be defined and initialized at the same time. If the variable is inside a struct, it must be <b>static</b> to be independant of any instance of the class;</li>
<li>is not a temporary. It has to be an lvalue ;</li>
<li>has <b>linkage</b>. The <b>inline</b> keyword guarentees extern linkage, unless the <b>static</b> keyword is used too outside of a struct. In this case, "static" implies internal linkage (unless you are inside a struct and <b>inline</b> is used) so linker errors may occur. The <b>extern</b> keyword cannot be applied to <b>constexpr</b> variables (because you must initialize a constexpr at the definition, which is not possible with <b>extern</b>).</li>
</ul>
<p>OmniUnit already implements some variables to represent the decimal system with ratios : </p><pre class="fragment">inline constexpr double E0 = 1.;
inline constexpr double E1 = 10.;
inline constexpr double E2 = 100.;
inline constexpr double E3 = 1000.;
inline constexpr double E4 = 10000.;
//...
inline constexpr double E90 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.;
//notice the point at the end of each value
</pre><p>Then, Omniunit defines some needed ratios to represent units (here are only a few of them) : </p><pre class="fragment">typedef Ratio&lt;E0, E9&gt; nano;
typedef Ratio&lt;E0, E6&gt; micro;
typedef Ratio&lt;E0, E3&gt; milli;
typedef Ratio&lt;E0, E0&gt; base;
typedef Ratio&lt;E3, E0&gt; kilo;
typedef Ratio&lt;E6, E0&gt; mega;
typedef Ratio&lt;E9, E0&gt; giga;
</pre><p>So, how to define a more complex ratio ? A minute contains 60 seconds. The ratio of the minute is 60/1 : </p><pre class="fragment">inline constexpr double secondsInMinute = 60.;
typedef omni::Ratio&lt;secondsInMinute, omni::E0&gt; minuteRatio;
</pre><p><b>Be aware</b> : <b>Ratio needs its parameters to be positive integers</b>. </p><pre class="fragment">inline constexpr double milliVar = 0.001;
typedef omni::Ratio&lt;milliVar, omni::E0&gt; milli; //ERROR : Ratio can only handle positive integers.
</pre><p>So... How to define pi (3.1415) as a Ratio (for some reasons) ? </p><pre class="fragment">inline constexpr double piE4 = 31415.;
typedef Ratio&lt;piE4, omni::E4&gt; pi;
</pre><p><b>Tips</b> : the value of the ratio is obtainable with ::value : </p><pre class="fragment">double a = pi::value    //a equals 3.1415
double b = omni::milli::value //b equals 0.001
</pre><p><b>Be aware</b> : <b>It won't compile if one of the parameters is an rvalue</b>. </p><pre class="fragment">typedef omni::Ratio&lt;omni::E0, 1000.&gt; milli;
//ERROR, 1000 is an rvalue, you have to define a constexpr variable which equals 1000.

typedef omni::Ratio&lt;omni::E0, omni::E3*omni::E3&gt; nano;
//ERROR, E3*E3 is an rvalue, you have to define a variable which equals either E3*E3 or 1000000.
</pre><p><b>Be aware</b> : <b>It won't work as expected with raised power dimensions</b>.</p>
<p>If you are defining surfaces for exemple, the corresponding dimension is omni::Dimension&lt;2, 0, 0, 0, 0, 0, 0, 0, 0&gt;</p>
<p>While the ratio of meter2 is 1/1 (aka omni::base) because it is the international surface unit, the ratio of deciMeter2 <b>IS NOT 1/10</b> (aka omni::deci) because 100 decimeters2 are needed to obtain a square meter. So the ratio of deciMeter2 <b>IS 1/100</b> (aka omni::centi).</p>
<p>Another exemple : the ratio of deciMeter3 is 1/1000 (aka omni::milli). The ratio of milliMeter3 is 1/1.000.000.000 (aka omni::nano).</p>
<p><b>In fact, if you raise your unit to power n, you have to raise its ratio to power n.</b></p>
<p>Well, lets make more tricky ratios :</p><ul>
<li>second4Ampere2PerMeter2kilogram2 (aka <b>farad</b>, the official capacitance unit, with dimension &lt;-2, -2, 4, 2, 0, 0, 0, 0, 0&gt;). Its ratio is 1/1.</li>
<li>millisecond4Ampere2PerMeter2kilogram2 have the ratio 1/1.000.000.000.000,</li>
<li>millisecond4Kiloampere2PerMeter2kilogram2 have the ratio 1.000.000/1.000.000.000.000 = 1/1.000.000,</li>
<li>millisecond4Kiloampere2Perkilometer2kilogram2 have the ratio 1.000.000/(1.000.000.000.000 * 1.000.000) = 1/1.000.000.000.000,</li>
</ul>
<p>Notice that the second one and the last one are the same units. Also notice that they are both the same thing as a picoFarad, and the third one is the same thing as a microFarad.</p>
<p>The unit milliFarad have a ratio equal to 1/1000 because 1000 milliFarads are needed to give 1 farad. Imagine the unit milliFarad2 (for some reasons) : its ratio is 1/1.000.000 because 1.000.000 milliFarads2 are needed to give one farad2.</p>
<p>Finally, there are some tricks to ease the definition of some ratios. The following type_traits are defined :</p><ul>
<li>Ratio_invert&lt;&gt;</li>
<li>Ratio_times_Ratio&lt;&gt;</li>
<li>Ratio_over_Ratio&lt;&gt;</li>
<li>Ratio_times_value&lt;&gt;</li>
<li>value_times_Ratio&lt;&gt;</li>
<li>Ratio_over_value&lt;&gt;</li>
<li>value_over_Ratio&lt;&gt;</li>
<li>Ratio_power&lt;&gt;</li>
<li>Ratio_root&lt;&gt;</li>
</ul>
<p>exemples of use : </p><pre class="fragment">typedef omni::Ratio_times_Ratio&lt;omni::milli, omni::milli&gt;::type micro;

inline constexpr double sixty = 60.;
typedef omni::Ratio&lt;sixty, omni::E0&gt; minuteRatio;
typedef omni::Ratio_times_value&lt;minuteRatio, sixty&gt;::type hourRatio;
typedef omni::Ratio_invert&lt;hourRatio&gt;::type perHourRatio;

//power and root only take exponent/basis as integer, so inline lvalue constexpr double isn't needed
typedef omni::Ratio_power&lt;hourRatio, 2&gt;::type hour2Ratio;
</pre><h2>Step 3 : Origin</h2>
<p>The zero of the new unit can be defferent of the zero of the official unit. For exemple, the official unit of temperature is the kelvin : 0°C = 273.15 kelvins, and 0°F = 255.372 kelvins.</p>
<p>So, what is called the origin of the new unit is the amount of the official unit of ratio 1/1 needed to get the 0 of the new unit. </p><pre class="fragment">    Origin = amount of official unit of ratio 1/1 needed to get the 0 of the new unit
</pre><p>Thus, the origin of fahrenheit is 255.372, the origin of celsius is 273.15, and the origin of microFahrenheit and kiloCelsius is still respectively 255.372 and 273.15 (because the origin is always given in ratio 1/1).</p>
<p>Most of the time, this origin equals 0.</p>
<p>Well, Origin is taken as <b>double</b> by <b>non-type</b> template parameter. So this value has to be of type <b>inline constexpr double</b>, must be an lvalue and must have linkage (see above, in "__Step 2 : Ratio__").</p>
<p><b>Be aware :</b> don't forget to raise the power of the origin for a raised power unit. For exemple, the origin of celsius2 is 74610.9225, those of celsius3 is 20379973.48, etc.</p>
<h2>Step 4 : Defining the new unit</h2>
<p>Once you have understood the three above steps, the definition of a new unit is quite simple : the class omni::Unit takes 4 templates arguments. In order, they are the dimension of the unit, the internal representation type of the handled value of the unit, the ratio of the unit, and the origin of the unit. Let's define a meter from scratch : </p><pre class="fragment">    // Definition of the dimension
    typedef omni::Dimension&lt;1,0,0,0,0,0,0,0,0&gt; Length;

    // Definition of the ratio
    inline constexpr double one = 1.;
    typedef omni::Ratio&lt;one, one&gt; base;

    // Definition of the origin
    inline constexpr double zero = 0.;

    // Definition of the new unit
    template &lt;typename Rep = OMNI_DEFAULT_TYPE&gt;
    using meter = omni::Unit&lt;Length, Rep, base, zero&gt;;

    // For each unit defined, you should define the default unit to be more user friendly
    typedef meter&lt;&gt; Meter;
</pre><p>And that's all ! </p><pre class="fragment">    // Enjoy and use your new unit
    meter&lt;int&gt; var1(10);
    meter&lt;&gt; var2(10);
    Meter var3(10);
</pre><p>Of course, the above exemple starts from nothing, but OmniUnit provides some dimensions, ratios and constexpr variables. You could define your meter like : </p><pre class="fragment">    template &lt;typename Rep = OMNI_DEFAULT_TYPE&gt;
    using meter = omni::Unit&lt;omni::Length, Rep, omni::base, omni::zero&gt;;
</pre><p>Here is a last exemple. Let's define the poise and the millipoise (they are non official viscosity unit) </p><pre class="fragment">typedef omni::Dimension&lt;-1,1,-1,0,0,0,0,0,0&gt; Viscosity;

template &lt;typename Rep = OMNI_DEFAULT_TYPE&gt;
using poise = omni::Unit&lt;Viscosity, Rep, omni::deci, omni::zero&gt;; // the ratio is deci because 10 poises are needed to obtain 1 poiseuille, the official viscosity unit

template &lt;typename Rep = OMNI_DEFAULT_TYPE&gt;
using millipoise_v1 = omni::Unit&lt;Viscosity, Rep, typename omni::Ratio_times_Ratio&lt;poise::period, omni::milli&gt;::type, omni::zero&gt;;

template &lt;typename Rep = OMNI_DEFAULT_TYPE&gt;
using millipoise_v2 = omni::Unit&lt;Viscosity, Rep, typename omni::Ratio_times_Ratio&lt;omni::deci, omni::milli&gt;::type, omni::zero&gt;;

template &lt;typename Rep = OMNI_DEFAULT_TYPE&gt;
using millipoise_v3 = omni::Unit&lt;Viscosity, Rep, omni::Ratio&lt;omni::E0, omni::E4&gt;, omni::zero&gt;;

template &lt;typename Rep = OMNI_DEFAULT_TYPE&gt;
using millipoise_v4 = omni::Unit&lt;Viscosity, Rep, typename omni::Ratio_over_value&lt;omni::deci, omni::E3&gt;::type, omni::zero&gt;;
</pre><p>You can see that there are many ways to define the same unit : millipoise_v1, millipoise_v2, millipoise_v3 and millipoise_v4 are exactly the same units.</p>
<h2>Bonus : defining litteral opertaor for your new unit</h2>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 6 2019 19:00:01 for OmniUnit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
