# 4. How to create units #

To define your own unit, you need to provide 3 informations : its dimension, its ratio and its origin. All must be done in a header file.

## Step 1 : Dimension ##

The class omni::Dimension has 9 template parameters which define the 7 basic international dimensions and 2 angular "dimensions". These parameters are, in order : length, mass, time, electric intensity, temperature, quantity, luminous intensity, angle and solid angle.

So, here are some examples of dimension definition :


    typedef omni::Dimension<1, 0, 0, 0, 0, 0, 0, 0, 0> Length;
    typedef omni::Dimension<0, 0, 1, 0, 0, 0, 0, 0, 0> Duration;
    typedef omni::Dimension<0, 0, -1, 0, 0, 0, 0, 0, 0> Frequency;
    typedef omni::Dimension<1, 0, -1, 0, 0, 0, 0, 0, 0> Speed;
    typedef omni::Dimension<2, 1, -2, 0, 0, 0, 0, 0, 0> Energy;
    typedef omni::Dimension<0, 1, -2, -1, 0, 0, 0, 0, 0> MegneticField;

__Tips__ : the function omni::dimension_str<>() returns a std::string containing the dimension passed as template argument, if you want to print it.

    std::string dim = omni::dimension_str<MegneticField>();
    std::cout << dim << "\n"; //prints: [M1][Tm-2][I-1]

## Step 2 : Ratio ##

The ratio indicates what the unit represents according to the basic international unit of the considered dimension.\n
For example, the basic unit of a length is the meter, represented by a ratio equal to 1 : it is the base. The basic unit of a charge is the coulomb, for a magnetic field it is the tesla... They are all represented by a ratio equal to 1 because they are the basic international unit of their dimension.\n
Thus, one millimeter represents 0.001 meter, namely 1/1000 meter. Obviously, the ratio for a millimeter is 1/1000, 1/1000000 for a micrometer, 1000/1 for a kilometer... 1/2 for a half-meter !\n

Well, omni::Ratio is a type which takes two values (a numerator and a denominator) as **non-type** template parameters. These parameters **HAVE TO** be of type __constexpr double__. \n
__Double__ are needed for technical reasons (the greater value reachable with an integer or a float is too short to represent all possible units, this is why OmniUnit doesn't use std::ratio). However, a template parameter can only be taken as double if the parameter :

* is **known at compile time**, so it has to be __constexpr__. (A constexpr variable must be defined and initialized at the same time) ;
* is not a temporary. It has to be an lvalue ;
* has **linkage**. So it has to be declared either directly in a namespace (or at global scope), or in a class body being __static__ (any constexpr value is known at compile time, so this value must be independant of any instance of the class, so it must be static). Note : A variable declared in a local scope (like a function or a member function) has **no linkage**, even being static (this point could change in C++20 in constexpr functions). To have linkage in a local scope, the variable must be declared __extern__, but a **constexpr** variable **cannot** be declared extern because a it has to be defined and initialized at the same time which is not possible for extern variables (in C++14).

OmniUnit already implements some variables to represent the decimal system with ratios :

    constexpr double E0 = 1.;
    constexpr double E1 = 10.;
    constexpr double E2 = 100.;
    constexpr double E3 = 1000.;
    constexpr double E4 = 10000.;
    //...
    constexpr double E90 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.;
    //notice the point at the end of each number

Then, Omniunit defines the needed ratios to represent units (here are only a few of them) :

    typedef Ratio<E0, E9> nano;
    typedef Ratio<E0, E6> micro;
    typedef Ratio<E0, E3> milli;
    typedef Ratio<E0, E0> base;
    typedef Ratio<E3, E0> kilo;
    typedef Ratio<E6, E0> mega;
    typedef Ratio<E9, E0> giga;

So, how to define a more complex ratio ? A minute contain 60 seconds. The ratio of the minute is 60/1 :

    constexpr double secondsInMinute = 60.;
    typedef omni::Ratio<secondsInMinute, omni::E0> minuteRatio;

__Be aware__ **: Ratio need its parameters to be positive integers**.

    constexpr double milliVar = 0.001;
    typedef omni::Ratio<milliVar, omni::E0> milli; //ERROR : Ratio can only handle positive integers.

So... How to define pi (3.1415) as a Ratio (for some reasons) ?

    constexpr double piE4 = 31415.;
    typedef Ratio<piE4, omni::E4> pi;

__Tips__ : the value of the ratio is obtainable with ::value :

    double a = pi::value    //a equals 3.1415
    double b = omni::milli::value //b equals 0.001

__Be aware__ **: It won't compile if one of the parameters is an rvalue**.

    typedef omni::Ratio<omni::E0, 1000.> milli;
    //ERROR, 1000 is an rvalue, you have to define a constexpr variable which equals 1000.

    typedef omni::Ratio<omni::E0, omni::E3*omni::E3> nano;
    //ERROR, E3*E3 is an rvalue, you have to define a variable which equals either E3*E3 or 1000000.

__Be aware__ **: It won't work as expected with raised power dimensions**.

If you are defining surfaces for exemple, the corresponding dimension is omni::Dimension<2, 0, 0, 0, 0, 0, 0, 0, 0>

While the ratio of meter2 is 1/1 (aka omni::base) because it is the international surface unit, the ratio of deciMeter2 **IS NOT 1/10** (aka omni::deci) because 100 decimeters2 are needed to obtain a square meter.
So the ratio of deciMeter2 **IS 1/100** (aka omni::centi).

Another exemple : the ratio of deciMeter3 is 1/1000 (aka omni::milli). The ratio of milliMeter3 is 1/1.000.000.000 (aka omni::nano).

Well, lets make a more tricky ratio :
* second4Ampere2PerMeter2kilogram2 (aka **farad**, the official capacitance unit, with dimension <-2, -2, 4, 2, 0, 0, 0, 0, 0>). Its ratio is 1/1.
* millisecond4Ampere2PerMeter2kilogram2 have the ratio 1/1.000.000.000.000,
* millisecond4Kiloampere2PerMeter2kilogram2 have the ratio 1.000.000/1.000.000.000.000 = 1/1.000.000,
* millisecond4Kiloampere2Perkilometer2kilogram2 have the ratio 1.000.000/(1.000.000.000.000 * 1.000.000) = 1/1.000.000.000.000,

Notice that the second one and the last one are the same units.
Also notice that they are both the same thing as a picoFarad, and the third one is the same thing as a microFarad.

The unit milliFarad have a ratio equal to 1/1000 because 1000 milliFarads are needed to give 1 farad.
Imagine the unit milliFarad2 (for some reasons) : its ratio is 1/1.000.000 because 1.000.000 milliFarads2 are needed to give one farad2.

Finally, there are some tricks to ease the definition of some complex ratios. The following type_traits are defined :
* Ratio_invert
* Ratio_times_Ratio
* Ratio_over_Ratio
* Ratio_times_value
* value_times_Ratio
* Ratio_over_value
* value_Over_Ratio
* Ratio_power
* Ratio_root

exemples :

    typedef omni::Ratio_times_Ratio<omni::milli, omni::milli>::type micro;

    constexpr double sixty = 60.;
    typedef omni::Ratio<sixty, omni::E0> minuteRatio;
    typedef omni::Ratio_times_value<minuteRatio, sixty>::type hourRatio;
    typedef omni::Ratio_invert<hourRatio>::type perHourRatio;

    //power and root only take integers as exponent/basis, so no lvalue constexpr double is needed
    typedef omni::Ratio_power<hourRatio>::type hour2Ratio;

## Step 3 : Origin ##

The zero of the new unit can be defferent of the zero of the official unit.
For exemple, the official unit of temperature is the kelvin : 0°C = 273.15 kelvins, and 0°F = 255.372 kelvins.

So, what is called the origin of the new unit is the amount of the official unit of ratio 1/1 needed to get the 0 of the new unit.

        Origin = amount of official unit of ratio 1/1 needed to get the 0 of the new unit

Thus, the origin of fahrenheit is 255.372, the origin of celsius is 273.15, and the origin of microFahrenheit and kiloCelsius is still respectively 255.372 and 273.15 (because the origin is always given in ratio 1/1).

Most of the time, this origin equals 0.

Well, Origin is taken as __double__ by **non-type** template parameter. So this value has to be of type __constexpr double__, must be an lvalue and must have linkage (see above, in "__Step 2 : Ratio__").

**Be aware :** don't forget to raise the power of the origin for a raised power unit. For exemple, the origin of celsius2 is 74610.9225, those of celsius3 is 20379973.48, etc.

## Step 4 : Defining the new unit ##

Once you have understood the three above steps, the definition of a new unit is quite simple : the class omni::Unit takes 4 templates arguments. In order, they are the dimension of the unit, the internal representation type of the handled value of the unit, the ratio of the unit, and the origin of the unit. Let's define a meter from scratch :

        // Definition of the dimension
        typedef omni::Dimension<1,0,0,0,0,0,0,0,0> Length;

        // Definition of the ratio
        constexpr double one = 1.;
        typedef omni::Ratio<one, one> base;

        // Definition of the origin
        constexpr double zero = 0.;

        // Definition of the new unit
        template <typename Rep = OMNI_DEFAULT_TYPE>
        using meter = omni::Unit<Length, Rep, base, zero>;

        // For each unit defined, you should define the default unit to be more user friendly
        typedef meter<> Meter;

And that's all !

        // Enjoy and use your new unit
        meter<int> var1(10);
        meter<> var2(10);
        Meter var3(10);

Of course, the above exemple starts from nothing, but OmniUnit provides some dimensions, ratios and constexpr variables. You could define your meter like :

        template <typename Rep = OMNI_DEFAULT_TYPE>
        using meter = omni::Unit<omni::Length, Rep, omni::base, omni::zero>;

Here is a last exemple. Let's define the poise and the millipoise (they are non official viscosity unit)

    typedef omni::Dimension<-1,1,-1,0,0,0,0,0,0> Viscosity;

    template <typename Rep = OMNI_DEFAULT_TYPE>
    using poise = omni::Unit<Viscosity, Rep, omni::deci, omni::zero>; // the ratio is deci because 10 poises are needed to obtain 1 poiseuille, the official viscosity unit

    template <typename Rep = OMNI_DEFAULT_TYPE>
    using millipoise_v1 = omni::Unit<Viscosity, Rep, typename omni::Ratio_times_Ratio<poise::period, omni::milli>::type, omni::zero>;

    template <typename Rep = OMNI_DEFAULT_TYPE>
    using millipoise_v2 = omni::Unit<Viscosity, Rep, typename omni::Ratio_times_Ratio<omni::deci, omni::milli>::type, omni::zero>;

    template <typename Rep = OMNI_DEFAULT_TYPE>
    using millipoise_v3 = omni::Unit<Viscosity, Rep, omni::Ratio<omni::E0, omni::E4>, omni::zero>;

    template <typename Rep = OMNI_DEFAULT_TYPE>
    using millipoise_v4 = omni::Unit<Viscosity, Rep, typename omni::Ratio_over_value<omni::deci, omni::E3>::type, omni::zero>;

You can see that there are many ways to define the same unit : millipoise_v1, millipoise_v2, millipoise_v3 and millipoise_v4 are exactly the same units.

## Bonus : defining litteral opertaor for your new unit ##