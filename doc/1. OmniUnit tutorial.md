# 1. OmniUnit tutorial #

# Pre-existing units #

## Use units and conversions ##

All libraries provided by Stabax are under namespace stb:: and each project has its namespace : stb::omni:: for OmniUnit. To avoid repetitive programing, you should put this line into your sources :

    #include "omniunit/omniunit.hh"
    using stb = stb::omni

OmniUnit defines some of the main physical units.
For example, for the mass dimension, these units are defined :

| **decimal system** | **other** |
| :---------------: | :-------: |
| zeptogram | atomic_mass |
| attogram | |
| femtogram | |
| picogram | |
| nanogram | nanoevPerC2 |
| microgram | microevPerC2 |
| milligram | millievPerC2 |
| centigram | |
| decigram | |
| gram | evPerC2 |
| decagram | |
| hectogram | |
| kilogram | kiloevPerC2 |
| megagram | megaevPerC2 |
| gigagram | gigaevPerC2 |
| teragram | teraevPerC2 |
| petagram | petaevPerC2 |
| exagram | |
| zettagram | ton |
| yottagram | solar_mass |

If you want to use an other mass unit which is not defined here, like the pound, see below how to easily create your units.

Units are generic. When you use them, you have to precise the arithmetic type which is handled inside them :

    #include "omniunit/omniunit.hh"
    using stb = stb::omni;

    int main()
    {
      stb::gram<int> var1(10);     //var1 equals 10
      stb::gram<int> var2(12.9);   //var2 equals 12, the value is truncated, not rounded
      stb::gram<float> var3(12.9); //var3 equals 12.9
      //you can of course use short, long, double, unsigned types...

      var1 = var3; //var1 equals 12, the value is truncated, not rounded

    return 0;
    };


You can convert a unit to another, implicitly or explicitly, if they have the same dimension (mass in these examples) :

    stb::kilogram<float> var1(3.1);
    stb::milligram<float> var2(var1);  //conversion by construction
    stb::milligram<float> var3 = var1; //conversion by assignment
    //var2 and var3 equal 3100000

    stb::ton<float> var4 = var1; //var4 equals 0.0031
    stb::ton<int> var5 = var1; //var5 equals 0, the value is truncate, not rounded

    //you can of course use explicit conversion, in C or C++ style :

    //C style, var6 is a stb::microgram<int>
    auto var6 = stb::microgram<int>(var1);

    //C++ style, var7 is a stb::microgram<int>
    auto var7 = stb::mass_cast<stb::microgram<int>>(var1);

    //more complex possibility :
    auto var8 = stb::mass_cast<int, stb::milli>(var1);
    //here, var8 is a stb::gram<int>
    //the first template argument is the type handled by the unit.
    //the second is a typedef of stb::Ratio (stb::milli is stb::Ratio<1, 1000>).
    //the international unit of mass is a kilogram, so stb::Ratio<1, 1> represents it. Thus, stb::milli represents a gram. Yeah, it's not intuitive at the first time. See below how to use stb::ratio.

    //last case :
    auto var9 = stb::unit_cast<stb::Mass, float, stb::micro>(var1);
    //var9 is a stb::milligram<float>
    //the first argument is a typedef of stb::Dimension (stb::Mass is stb::Dimension<0, 1, 0, 0, 0, 0, 0>). If you use stb::Length here, it would not compile because var1 is a mass. See below how to use stb::Dimension.


## Compliance between standard duration and OmniUnit duration ##

## Dimension composition and compile-time check ##

## Calculation and propagation of uncertainties ##

# Create your own units #

## Step 1 : Dimension ##

## Step 2 : Ratio ##

## Step 3 : Unit ##

## Declare your own cast function ##
