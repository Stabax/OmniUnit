# 1. OmniUnit tutorial #

# Pre-existing units #

## Use units and conversions ##

All libraries provided by Stabax are under namespace stb:: and each project has its namespace : stb::omni:: for OmniUnit. To avoid repetitive programing, you should put this line into your sources :

    #include "omniunit/omniunit.hh"
    using stb = stb::omni

OmniUnit defines some of the main physical units.
For example, for the mass dimension, these units are defined :

| **decimal system** | **particle scale** | **astronomic scale** |**other** |
| :----------------: | :-----------------: | :-------------------: | :------: |
| zeptogram | | | |
| attogram | | | |
| femtogram | | | |
| picogram | | | |
| nanogram | nanoevPerC2 | | |
| microgram | microevPerC2 | | |
| milligram | millievPerC2 | | |
| centigram | | | |
| decigram | | | |
| gram | evPerC2 | | |
| decagram | | | |
| hectogram | | | |
| kilogram | kiloevPerC2 | | |
| megagram | megaevPerC2 | | |
| gigagram | gigaevPerC2 | | |
| teragram | teraevPerC2 | | |
| petagram | petaevPerC2 | | |
| exagram | | | |
| zettagram | | | ton |
| yottagram | atomic_mass | solar_mass | |

If you want to use an other mass unit which is not defined here, like the pound, see below how to easily create your units.

See all the defined dimensions and units here : http://stabax.org/doc/omniunit/md_doc_1_81_8_List_of_all_defined_units.html
If a dimension is not defined, like electric conductivity or hypervolume, you can indeed create them, see below.

Units are generic. When you use them, you have to precise the arithmetic type which is handled inside them :

    #include "omniunit/omniunit.hh"
    using stb = stb::omni;

    int main()
    {
      stb::gram<int> var1(10);     //var1 equals 10
      stb::gram<int> var2(12.9);   //var2 equals 12, the value is truncated, not rounded
      stb::gram<float> var3(12.9); //var3 equals 12.9
      //you can of course use short, long, double, unsigned types...

      var1 = var3; //var1 equals 12, the value is truncated, not rounded

    return 0;
    };


You can convert a unit to another, implicitly or explicitly, if they have the same dimension (mass in these examples) :

    stb::kilogram<float> var1(3.1);
    stb::milligram<float> var2(var1);  //conversion by construction
    stb::milligram<float> var3 = var1; //conversion by assignment
    //var2 and var3 equal 3100000

    stb::ton<float> var4 = var1; //var4 equals 0.0031
    stb::ton<int> var5 = var1; //var5 equals 0, the value is truncate, not rounded

    //you can of course use explicit conversion, in C or C++ style :

    //C style, var6 is a stb::microgram<int>
    auto var6 = stb::microgram<int>(var1);

    //C++ style, var7 is a stb::microgram<int>
    auto var7 = stb::mass_cast<stb::microgram<int>>(var1);

    //more complex possibility :
    auto var8 = stb::mass_cast<int, stb::milli>(var1);
    //here, var8 is a stb::gram<int>
    //the first template argument is the type handled by the unit.
    //the second is a typedef of stb::Ratio (stb::milli is stb::Ratio<1, 1000>).
    //the international unit of mass is a kilogram, so stb::Ratio<1, 1> represents it.
    //Thus, stb::milli represents a gram. Yeah, it's not intuitive at the first time.
    //See below how to use stb::ratio.

    //last case :
    auto var9 = stb::unit_cast<stb::Mass, float, stb::micro>(var1);
    //var9 is a stb::milligram<float>
    //the first argument is a typedef of stb::Dimension (stb::Mass is stb::Dimension<0, 1, 0, 0, 0, 0, 0>).
    //If you use stb::Length here, it would not compile because var1 is a mass.
    //See below how to use stb::Dimension.


## Compliance between standard duration and OmniUnit duration ##

If you are familiar with standard duration (std::chrono::duration), you may want to use them and to convert them into OmniUnit duration, and vice versa.

Happily, there is a full compliance. You can simply do this by constructing or assigning them :

    stb::millisecond<float> omni1(1.8);

    std::chrono::hours standard1(omni1); //construction
    //conversion is done implicitly (moreover, std::chrono::hour handle an integer while stb::millisecond<float> handle a float... so standard1 equals 1, not 1.8)

    std::chrono::minutes standard2 = omni1; //same thing, but with assignment instead of construction

    //reciprocally
    omni1 = standard2; //assignment
    stb::year<int> omni2(standard2); //construction

    //explicit conversion between standard and OmniUnit duration in C and C++ style

    //C style
    auto omni3 = stb::second<unsigned>(standard1);
    auto standard3 = std::chrono::seconds(omni2);

    //C++ style
    auto omni4 = stb::duration_cast<stb::second<int>>(standard3);
    auto standard4 = stb::duration_cast<std::chrono::nanoseconds>(omni3);

    //more complex possibility
    auto standard5 = stb::duration_cast<int, std::chrono::milli>(omni4);
    //here, duration cast knows it has to return a standard duration instead of a OmniUnit duration because the second template argument is a standard ratio, not a OmniUnit ratio.

However, you can't use an implicit conversion between standard and OmniUnit to pass a parameter to a function, you have to do this explicitly :

    void foo1(std::chrono::hours);
    void foo2(stb::second<int>);

    std::chrono::seconds standard1(1);
    stb::millisecond<float> omni1(2.1);

    foo1(omni1); //ERROR
    foo1(std::chrono::hours(omni1)); //OK
    foo1(stb::duration_cast<std::chrono::hours>(omni1)); //OK

    foo2(standard1); //ERROR
    foo2(stb::second<int>(standard1)); //OK
    foo2(stb::duration_cast<stb::second<int>(standard1)); //OK

## Dimension composition and compile-time check ##

## Calculation and propagation of uncertainties ##

# Create your own units #

## Step 1 : Dimension ##

## Step 2 : Ratio ##

## Step 3 : Unit ##

## Declare your own cast function ##
