# 1. OmniUnit tutorial #

# Pre-existing units #

## Use units and conversions ##

All libraries provided by Stabax are under namespace stb:: and each project has its namespace : stb::omni:: for OmniUnit. To avoid repetitive programing, you should put this line into your sources :

    #include "omniunit/omniunit.hh"
    using stb = stb::omni;

OmniUnit defines some of the main physical units.
For example, for the mass dimension, these units are defined :

| **decimal system** | **microscopic system** | **astronomic system** | **other** |
| :----------------: | :--------------------: | :-------------------: | :-------: |
| yoctogram | | | |
| zeptogram | | | |
| attogram | | | |
| femtogram | | | |
| picogram | | | |
| nanogram | nanoevPerC2 | | |
| microgram | microevPerC2 | | |
| milligram | millievPerC2 | | |
| centigram | | | |
| decigram | | | |
| gram | evPerC2 | | |
| decagram | | | |
| hectogram | | | |
| kilogram | kiloevPerC2 | | |
| megagram | megaevPerC2 | | ton |
| gigagram | gigaevPerC2 | | |
| teragram | teraevPerC2 | | |
| petagram | petaevPerC2 | | |
| exagram | | | |
| zettagram | | | |
| yottagram | atomic_mass | solar_mass | |

If you want to use an other mass unit which is not defined here, like the **pound**, see below how to easily create your units in __"Create your own units"__.

See all the defined dimensions and units here : http://stabax.org/doc/omniunit/md_doc_1_81_8_List_of_all_defined_units.html
If a dimension is not defined, like **electric conductivity** or **hypervolume**, you can indeed create them, see below in __"Create your own units"__.

Units are generic. When you use them, you have to precise the arithmetic type which is handled inside them :

    #include "omniunit/omniunit.hh"
    using stb = stb::omni;

      stb::gram<int> var1(10);     //var1 equals 10
      stb::gram<int> var2(12.9);   //var2 equals 12, the value is truncated, not rounded
      stb::gram<float> var3(12.9); //var3 equals 12.9
      //you can of course use short, long, double, unsigned types...

      var1 = var3; //var1 equals 12, the value is truncated, not rounded

You can convert a unit to another, implicitly or explicitly, if they have the same dimension (mass in these examples) :

    stb::kilogram<float> var1(3.1);
    stb::milligram<float> var2(var1);  //conversion by construction
    stb::milligram<float> var3 = var1; //conversion by assignment
    //var2 and var3 equal 3100000

    stb::ton<float> var4 = var1; //var4 equals 0.0031
    stb::ton<int> var5 = var1; //var5 equals 0, the value is truncate, not rounded

    //you can of course use explicit conversion, by construction or explicit cast :

    //construction, var6 is a stb::microgram<int>
    auto var6 = stb::microgram<int>(var1);

    //explicit cast, var7 is a stb::microgram<int>
    auto var7 = stb::mass_cast<stb::microgram<int>>(var1);

    //more complex possibility :
    auto var8 = stb::mass_cast<int, stb::milli>(var1);
    //here, var8 is a stb::gram<int>
    //the first template argument is the type handled by the unit.
    //the second is a typedef of stb::Ratio (stb::milli is stb::Ratio<1, 1000>).
    //the international unit of mass is a kilogram, so stb::Ratio<1, 1> represents it.
    //Thus, stb::milli represents a gram. Yeah, it's not intuitive at the first time.
    //See below how to use stb::ratio.

    //last case :
    auto var9 = stb::unit_cast<stb::Mass, float, stb::micro>(var1);
    //var9 is a stb::milligram<float>
    //the first argument is a typedef of stb::Dimension (stb::Mass is stb::Dimension<0, 1, 0, 0, 0, 0, 0>).
    //If you use stb::Length here, it would not compile because var1 is a mass.
    //See below how to use stb::Dimension.


## Compliance between standard duration and OmniUnit duration ##

If you are familiar with standard duration (std::chrono::duration), you may want to use them and to convert them into OmniUnit duration, and vice versa.

Happily, there is a full compliance. You can simply do this by constructing or assigning them :

    stb::millisecond<float> omni1(1.8);

    std::chrono::hours standard1(omni1); //construction
    //conversion is done implicitly
    //(moreover, std::chrono::hour handle an integer while stb::millisecond<float> handle a float...
    //so standard1 equals 1, not 1.8)

    std::chrono::minutes standard2 = omni1; //same thing, but with assignment instead of construction

    //reciprocally
    omni1 = standard2; //assignment
    stb::year<int> omni2(standard2); //construction

    //explicit conversion between standard and OmniUnit duration in C and C++ style

    //C style
    auto omni3 = stb::second<unsigned>(standard1);
    auto standard3 = std::chrono::seconds(omni2);

    //C++ style
    auto omni4 = stb::duration_cast<stb::second<int>>(standard3);
    auto standard4 = stb::duration_cast<std::chrono::nanoseconds>(omni3);

    //more complex possibility
    auto standard5 = stb::duration_cast<int, std::chrono::milli>(omni4);
    //here, duration cast knows it has to return a standard duration instead of a OmniUnit duration
    //because the second template argument is a standard ratio, not a OmniUnit ratio.

However, you can't use an implicit conversion between standard and OmniUnit to pass a duration parameter to a function, you have to do this explicitly :

    void foo1(std::chrono::hours);
    void foo2(stb::second<int>);

    std::chrono::seconds standard1(1);
    stb::millisecond<float> omni1(2.1);

    foo1(omni1); //ERROR
    foo1(std::chrono::hours(omni1)); //OK
    foo1(stb::duration_cast<std::chrono::hours>(omni1)); //OK

    foo2(standard1); //ERROR
    foo2(stb::second<int>(standard1)); //OK
    foo2(stb::duration_cast<stb::second<int>(standard1)); //OK

## Dimension composition and compile-time check ##

## Calculation and propagation of uncertainties ##

# Create your own units #

To define a unit, you need to provide its dimension and its ratio.

## Step 1 : Dimension ##

The class stb::omni::Dimension has 7 templates parameters which define the 7 basic international dimensions. The order is length, mass, time, electric intensity, temperature, quantity and luminosity.

So, here are some example of dimension definition :

length dimension :

    typedef stb::omni::Dimension<1, 0, 0, 0, 0, 0, 0> Length;

duration dimension :

    typedef stb::omni::Dimension<0, 0, 1, 0, 0, 0, 0> Duration;

frequency dimension :

    typedef stb::omni::Dimension<0, 0, -1, 0, 0, 0, 0> Frequency;

speed dimension :

    typedef stb::omni::Dimension<1, 0, -1, 0, 0, 0, 0> Speed;

energy dimension :

    typedef stb::omni::Dimension<2, 1, -2, 0, 0, 0, 0> Energy;

magnetic fiels dimension :

    typedef stb::omni::Dimension<0, 1, -2, -1, 0, 0, 0> MegneticField;

Note : the function stb::omni::dimension_str() returns a std::string containing the dimension passed as template argument, if you want to print it.

    std::string dim = stb::omni::dimention_str<MegneticField>();
    std::cout << dim << '\\n'; //prints: \[M1]\[Tm-2]\[I-1]

## Step 2 : Ratio ##

The ratio indicates what the unit represents according to the basic international unit of the considered dimension.\n
For example, the basic unit of a length is the meter, represented by a ratio equal to 1 : it is the base. The basic unit of a charge is the coulomb, for a magnetic field it is the tesla... They are all represented by a ratio equal to 1 because they are the basic international unit of their dimension.\n
Thus, one millimeter represents 0.001 meter, namely 1/1000 meter. Obviously, the ratio for a millimeter is 1/1000, 1/1000000 for a nanometer, 1000/1 for a kilometer... 1/2 for a half-meter !\n

Well, stb::onmi::ratio is type which takes two template parameters. These parameter **HAS TO** have the type __static constexpr double___. __Double__ are needed for technical reasons (the greater value reachable with an integer or a float is too short to represent all possible units), but a template parameter can only be taken as double if :

* It is **known at compile time**, so it has to be __constexpr__,
* It must **have linkage**. So it has to be declared either directly in a namespace (or at global scope) or in a class body being __static__ (because it is constexpr). It **cannot** be declared in a local scope like a function or a member function, even being static.
* It is not a temporary. It has to be an lvalue.

OmniUnit already implements the needed variables to represent the decimal system with ratios :

    constexpr double E0 = 1.;
    constexpr double E1 = 10.;
    constexpr double E2 = 100.;
    constexpr double E3 = 1000.;
    constexpr double E4 = 10000.;
    //...
    constexpr double E80 = 100000000000000000000000000000000000000000000000000000000000000000000000000000000.;

Then, ratios are defined :

    typedef Ratio<E0, E9> nano;
    typedef Ratio<E0, E6> micro;
    typedef Ratio<E0, E3> milli;
    typedef Ratio<E0, E0> base;
    typedef Ratio<E3, E0> kilo;
    typedef Ratio<E6, E0> mega;
    typedef Ratio<E9, E0> giga;

Etc...\n
So, how to define more complex ratio ? A minute contain 60 seconds. The ratio of the minute is 60.

    static constexpr double secondsInMinute = 60.;
    typedef stb::omni::Ratio<secondsInMinute, E0> minuteRatio;

__Be aware__ : **It won't compile if one of the double value is not an integer**.

    static constexpr double milliVar = 0.001;
    typedef stb::omni::Ratio<milliVar, E0> milli;
    //ERROR : it is valid mathematically but in OmniUnit, decimals cannot be handled.

__Be aware__ : **It won't compile if one of the double is an rvalue**.

    typedef stb::omni::Ratio<E0, 1000> milli;
    //ERROR, 1000 is an rvalue, you have to define a variable which equals 1000.
    typedef stb::omni::Ratio<E0, E3*E3> nano;
    //ERROR, E3*E3 is an rvalue, you have to define a variable which equals 1000000.

## Step 3 : Unit ##

## Declare your own cast function ##
