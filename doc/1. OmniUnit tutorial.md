# 1. OmniUnit tutorial #

# Pre-existing units #

## Use units and conversions ##

All the library is under the namespace omniunit::.

OmniUnit defines some of the main physical units.
For example, for the mass dimension, these units are defined :

| **metric** | **microscopic** | **astronomic** | **imperial** | **other** |
| :----------------: | :--------------------: | :-------------------: | :-------: | :-------: |
| yoctogram | | | | |
| zeptogram | | | | |
| attogram | | | | |
| femtogram | | | | |
| picogram | | | | |
| nanogram | nanoevPerC2 | | | |
| microgram | microevPerC2 | | | |
| milligram | millievPerC2 | | | |
| centigram | | | | |
| decigram | | | | |
| gram | evPerC2 | | | |
| decagram | | | | |
| hectogram | | | | |
| kilogram | kiloevPerC2 | | | |
| megagram | megaevPerC2 | | | ton |
| gigagram | gigaevPerC2 | | | |
| teragram | teraevPerC2 | | | |
| petagram | petaevPerC2 | | | |
| exagram | | | | |
| zettagram | | | | |
| yottagram | atomic_mass | solar_mass | | |

See all the defined dimensions and units here : http://stabax.org/doc/omniunit/md_doc_1_81_8_List_of_all_defined_units.html

If you want to use another mass unit which is not defined here, like the **pound**, see below how to easily create your own units : __"Create your own units"__.
If a dimension is not defined, like **electric conductivity** or **hypervolume**, you can indeed create it, see below : __"Create your own units"__.

Units are generic. When you use them, you have to precise the arithmetic type which is handled inside them :

    #include "omniunit/omniunit.hh"

      omniunit::gram<int> var1(10);     //var1 equals 10
      omniunit::gram<int> var2(12.9);   //var2 equals 12, the value is truncated, not rounded
      omniunit::gram<float> var3(12.9); //var3 equals 12.9
      //you can of course use short, long, double, unsigned types...

      var1 = var3; //var1 equals 12, the value is truncated, not rounded

You can convert a unit to another, implicitly or explicitly, if they have the same dimension (mass in these examples) :

    omniunit::kilogram<float> var1(3.1);
    omniunit::milligram<float> var2(var1);  //conversion by construction
    omniunit::milligram<float> var3 = var1; //conversion by assignment
    //var2 and var3 equal 3100000

    omniunit::ton<float> var4 = var1; //var4 equals 0.0031
    omniunit::ton<int> var5 = var1; //var5 equals 0, the value is truncated, not rounded

    //you can of course use explicit conversion, by construction or explicit cast :

    //construction, var6 is a omniunit::microgram<int>
    auto var6 = omniunit::microgram<int>(var1);

    //explicit cast, var7 is a omniunit::microgram<int>
    auto var7 = omniunit::mass_cast<omniunit::microgram<int>>(var1);

    //more complex possibility :
    auto var8 = omniunit::mass_cast<int, omniunit::milli>(var1);
    //here, var8 is a omniunit::gram<int>
    //the first template argument is the type handled by the unit.
    //the second is a typedef of omniunit::Ratio (omniunit::milli is omniunit::Ratio<1, 1000>).
    //the international unit of mass is a kilogram, so omniunit::Ratio<1, 1> represents it.
    //Thus, omniunit::milli represents a gram. Yeah, it's not intuitive at the first time.
    //See below how to use omniunit::ratio.

    //last case :
    auto var9 = omniunit::unit_cast<omniunit::Mass, float, omniunit::micro>(var1);
    //var9 is a omniunit::milligram<float>
    //the first argument is a typedef of omniunit::Dimension (omniunit::Mass is omniunit::Dimension<0, 1, 0, 0, 0, 0, 0>).
    //If you use omniunit::Length here, it would not compile because var1 is a mass.
    //See below how to use omniunit::Dimension.


## Compliance between standard duration and OmniUnit duration ##

If you are familiar with standard duration (std::chrono::duration), you may want to use them and to convert them into OmniUnit duration, and vice versa.

Happily, there is a full compliance. You can simply do this by constructing or assigning them :

    omniunit::millisecond<float> omni1(1.8);

    std::chrono::hours standard1(omni1); //construction
    //conversion is done implicitly
    //(moreover, std::chrono::hour handle an integer while omniunit::millisecond<float> handle a float...
    //so standard1 equals 1, not 1.8)

    std::chrono::minutes standard2 = omni1; //same thing, but with assignment instead of construction

    //reciprocally
    omni1 = standard2; //assignment
    omniunit::year<int> omni2(standard2); //construction

    //explicit conversion between standard and OmniUnit duration in C and C++ style

    //C style
    auto omni3 = omniunit::second<unsigned>(standard1);
    auto standard3 = std::chrono::seconds(omni2);

    //C++ style
    auto omni4 = omniunit::duration_cast<omniunit::second<int>>(standard3);
    auto standard4 = omniunit::duration_cast<std::chrono::nanoseconds>(omni3);

    //more complex possibility
    auto standard5 = omniunit::duration_cast<int, std::chrono::milli>(omni4);
    //here, duration cast knows it has to return a standard duration instead of a OmniUnit duration
    //because the second template argument is a standard ratio, not a OmniUnit ratio.

However, you can't use an implicit conversion between standard and OmniUnit to pass a duration parameter to a function, you have to do this explicitly :

    void foo1(std::chrono::hours) {//do something};
    void foo2(omniunit::second<int>) {//do something};

    std::chrono::seconds standard(1);
    omniunit::millisecond<float> omni(2.1);

    foo1(omni); //ERROR
    foo1(std::chrono::hours(omni)); //OK
    foo1(omniunit::duration_cast<std::chrono::hours>(omni)); //OK

    foo2(standard1); //ERROR
    foo2(omniunit::second<int>(standard1)); //OK
    foo2(omniunit::duration_cast<omniunit::second<int>(standard)); //OK

## Dimension composition and compile-time check ##

## Calculation and propagation of uncertainties ##

# Create your own units #

To define a unit, you need to provide its dimension and its ratio.

## Step 1 : Dimension ##

The class omniunit::Dimension has 9 templates parameters which define the 7 basic international dimensions and 2 angular "dimensions". In order, these parameters are length, mass, time, electric intensity, temperature, quantity, luminosity, angle and solid_angle.

So, here are some example of dimension definition :

length dimension :

    typedef omniunit::Dimension<1, 0, 0, 0, 0, 0, 0, 0, 0> Length;

duration dimension :

    typedef omniunit::Dimension<0, 0, 1, 0, 0, 0, 0, 0, 0> Duration;

frequency dimension :

    typedef omniunit::Dimension<0, 0, -1, 0, 0, 0, 0, 0, 0> Frequency;

speed dimension :

    typedef omniunit::Dimension<1, 0, -1, 0, 0, 0, 0, 0, 0> Speed;

energy dimension :

    typedef omniunit::Dimension<2, 1, -2, 0, 0, 0, 0, 0, 0> Energy;

magnetic fiels dimension :

    typedef omniunit::Dimension<0, 1, -2, -1, 0, 0, 0, 0, 0> MegneticField;

Note : the function omniunit::dimension_str() returns a std::string containing the dimension passed as template argument, if you want to print it.

    std::string dim = omniunit::dimension_str<MegneticField>();
    std::cout << dim << '\\n'; //prints: \[M1]\[Tm-2]\[I-1]

## Step 2 : Ratio ##

The ratio indicates what the unit represents according to the basic international unit of the considered dimension.\n
For example, the basic unit of a length is the meter, represented by a ratio equal to 1 : it is the base. The basic unit of a charge is the coulomb, for a magnetic field it is the tesla... They are all represented by a ratio equal to 1 because they are the basic international unit of their dimension.\n
Thus, one millimeter represents 0.001 meter, namely 1/1000 meter. Obviously, the ratio for a millimeter is 1/1000, 1/1000000 for a nanometer, 1000/1 for a kilometer... 1/2 for a half-meter !\n\n

Well, omniunit::Ratio is a type which takes two values (a numerator and a denominator) as **non-type** template parameters. These parameters **HAVE TO** be of type __constexpr double__. \n
__Double__ are needed for technical reasons (the greater value reachable with an integer or a float is too short to represent all possible units, this is why OmniUnit doesn't use std::ratio). However, a template parameter can only be taken as double if the parameter :

* is **known at compile time**, so it has to be __constexpr__. (A constexpr variable must be defined and initialized at the same time) ;
* is not a temporary. It has to be an lvalue ;
* has **linkage**. So it has to be declared either directly in a namespace (or at global scope), or in a class body being __static__ (any constexpr value is known at compile time, so this value must be independant of any instance of the class, so it must be static). Note : A variable declared in a local scope (like a function or a member function, static or not) has **no linkage**, even being static (this point could change in C++20 in constexpr functions). To have linkage in a local scope, the variable must be declared __extern__, but : a **constexpr** variable **cannot** be declared extern because a constexpr variable has to be defined and initialized at the same time which is not possible for extern variables.

OmniUnit already implements the needed variables to represent the decimal system with ratios :

    constexpr double E0 = 1.;
    constexpr double E1 = 10.;
    constexpr double E2 = 100.;
    constexpr double E3 = 1000.;
    constexpr double E4 = 10000.;
    //...
    constexpr double E90 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.;
    //notice the point at the end of each number

Then, Omniunit defines the needed ratios to represent units (here are only a few of them) :

    typedef Ratio<E0, E9> nano;
    typedef Ratio<E0, E6> micro;
    typedef Ratio<E0, E3> milli;
    typedef Ratio<E0, E0> base;
    typedef Ratio<E3, E0> kilo;
    typedef Ratio<E6, E0> mega;
    typedef Ratio<E9, E0> giga;

So, how to define a more complex ratio ? A minute contain 60 seconds. The ratio of the minute is 60/1 :

    constexpr double secondsInMinute = 60.;
    typedef omniunit::Ratio<secondsInMinute, E0> minuteRatio;

**__Be aware__ : It won't compile if one of the double value is not a positive integer**.

    constexpr double milliVar = 0.001;
    typedef omniunit::Ratio<milliVar, E0> milli;
    //ERROR : a ratio can only handle positive integers (even is their type is double...).

So... How to define an approximation of pi (lets tell 3.1415) for some reason ?

    constexpr double piE4 = 31415.;
    typedef Ratio<piE4, E4> pi;

Tips : the value of the ratio is obtainable through ::value :

    (constexpr) double a = pi::value    //a equals 3.1415
    (constexpr) double b = milli::value //b equals 0.001

**__Be aware__ : It won't compile if one of the parameters is an rvalue**.

    typedef omniunit::Ratio<E0, 1000.> milli;
    //ERROR, 1000 is an rvalue, you have to define a constexpr variable which equals 1000.

    typedef omniunit::Ratio<E0, E3*E3> nano;
    //ERROR, E3*E3 is an rvalue, you have to define a variable which equals either E3*E3 or 1000000.

## Step 3 : Unit ##

## Declare your own cast function ##
